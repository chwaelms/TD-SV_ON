<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>BLE Audio Recorder</title>
    <style>
        #status {
            margin: 20px 0;
            padding: 10px;
            background-color: #f0f0f0;
        }
    </style>
</head>
<body>
    <button id="connect">Connect to BLE Device</button>
    <button id="save" disabled>Save Recording</button>
    <div id="status">Status: Disconnected</div>

    <script>
    const serviceUUID = 0x00FF;
    const characteristicUUID = 0xFF01;
    const options = {
        filters:[{services: [serviceUUID]}],
        optionalServices: []
    };

    const statusDisplay = document.getElementById('status');
    const saveButton = document.getElementById('save');
    let audioData = []; // 오디오 데이터를 저장할 배열

    function handleValueChange(event) {
        const data = new Int16Array(event.target.value.buffer);
        audioData.push(...data);
        statusDisplay.textContent = `Status: Recording... (Samples: ${audioData.length})`;
    }

    // WAV 파일 헤더 생성
    function createWavHeader(sampleRate, bitsPerSample, numberOfChannels, numberOfSamples) {
        const buffer = new ArrayBuffer(44);
        const view = new DataView(buffer);

        // "RIFF" 청크
        view.setUint32(0, 0x52494646, false); // "RIFF"
        view.setUint32(4, 36 + numberOfSamples * 2, true); // 파일 크기
        view.setUint32(8, 0x57415645, false); // "WAVE"

        // "fmt " 청크
        view.setUint32(12, 0x666D7420, false); // "fmt "
        view.setUint32(16, 16, true); // fmt 청크 크기
        view.setUint16(20, 1, true); // 오디오 포맷 (1 = PCM)
        view.setUint16(22, numberOfChannels, true); // 채널 수
        view.setUint32(24, sampleRate, true); // 샘플레이트
        view.setUint32(28, sampleRate * numberOfChannels * (bitsPerSample/8), true); // 바이트레이트
        view.setUint16(32, numberOfChannels * (bitsPerSample/8), true); // 블록 얼라인
        view.setUint16(34, bitsPerSample, true); // 비트 뎁스

        // "data" 청크
        view.setUint32(36, 0x64617461, false); // "data"
        view.setUint32(40, numberOfSamples * 2, true); // 데이터 크기

        return buffer;
    }

    function saveToWav() {
        const sampleRate = 16000;
        const numberOfChannels = 1;
        const bitsPerSample = 16;

        // WAV 헤더 생성
        const header = createWavHeader(sampleRate, bitsPerSample, numberOfChannels, audioData.length);

        // 오디오 데이터를 Int16Array로 변환
        const audioBuffer = new Int16Array(audioData);

        // 헤더와 오디오 데이터 합치기
        const blob = new Blob([header, audioBuffer], { type: 'audio/wav' });

        // 다운로드 링크 생성
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'recorded_audio.wav';
        a.click();

        // 메모리 정리
        URL.revokeObjectURL(url);
    }

    document.getElementById('connect').addEventListener('click', async() => {
        try {
            device = await navigator.bluetooth.requestDevice(options);
            const server = await device.gatt.connect();
            const service = await server.getPrimaryService(serviceUUID);
            characteristic = await service.getCharacteristic(characteristicUUID);
            await characteristic.startNotifications();
            
            characteristic.addEventListener(
                "characteristicvaluechanged",
                handleValueChange
            );

            statusDisplay.textContent = "Status: Connected and Recording";
            saveButton.disabled = false;
            
        } catch (error) {
            console.error("Bluetooth Error:", error);
            statusDisplay.textContent = "Status: Error - " + error.message;
        }
    });

    document.getElementById('save').addEventListener('click', () => {
        if (audioData.length > 0) {
            saveToWav();
            statusDisplay.textContent = "Status: Recording saved";
        } else {
            statusDisplay.textContent = "Status: No data to save";
        }
    });
    </script>
</body>
</html>
